## JDK8 中接口的新特性

- JDK7 及以前：只能定义全局变量和抽象方法
  - 全局常量：public static final 的，但是书写时，可以省略不写。
  - 抽象方法：public abstract 的，但是书写时，可以省略不写。
- JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法

Java8中，可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。

- 静态方法：使用`static`关键字修饰。**可以通过接口直接调用静态方法**，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。我们可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。

- 默认方法：默认方法使用`default`关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与就版本代码的兼容性。比如：java8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。



### 知识点：

1. 接口中定义的静态方法，只能通过接口来调用

2. 通过实现类的对象，可以调用接口中的默认方法

   如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写的方法

3. **如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的而方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（与变量不同，变量的调用必须声明调用的是接口中的还是类中的）。 ---> 类优先原则**

4. **如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，会报错 ---> 接口冲突。**（如果该实现类的父类中也有该方法则不会报错）

   这就需要我们必须再实现类中出重写此方法。

5. 如何在子类（或实现类）的方法中调用父类、接口中被重写的方法。

   ```java
   public void myMethod() {
   	method3(); // 调用自己定义的重写的方法method3()
   	super.method3(); // 调用父类中的method3()
   	
   	// 调用接口中的默认方法
   	CompareA.super.method3();
   	CompareB.super.method4();
   }
   ```

   